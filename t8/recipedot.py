"""
Export recipe to dot.

Initially based on
    https://waa.ai/OJcb

Why:
----
The default dot file generated by visualizing a textX model is
not enough. It's too "noisy" and complicated; therefore, we'll
use the model to generate our own "domain-specific viewer" to
visualize a recipe.
"""

from __future__ import unicode_literals
import codecs
import sys
from os.path import dirname, join
from textx import metamodel_from_file


DOT = '''
    digraph recipe {
    fontname = "Open Sans"
    fontsize = 8
    node[
        shape=record
        style=rounded
    ]
    edge[dir=black]
'''


""" Function used to translate the model to a dot file. """
def recipe_to_dot(model):
    dot_str = DOT

    quantities = []
    for quant in model.ingredients.quantity:
        if quant.unity == None:
            quantities.append(str(quant.quantity))
        else:
            quantities.append(str(quant.quantity) + " " + quant.unity)

    # Ingredients
    ingredients = dict(zip(
                       model.ingredients.ingredient,
                       quantities))

    # Rendering label: recipe name + ingredients
    dot_str += 'recipe_name [label="{{{}|{}}}", style=""]\n'\
               .format(model.name.name,
                       "\\n".join("{} . . . . . {}"
                            .format(k, v) for k, v in ingredients.items()))

    # Getting steps
    step_names = [model.name for model in model.steps]
    step_descr = []
    for step in model.steps:
        descr_time = [descr + ", " + str(time.time) + " " + str(time.unity) if time != "" else descr for descr, time in zip(step.descr, step.time)]
        step_descr.append(descr_time)

    # Rendering steps and transitions
    first = True
    for idx, step in enumerate(model.steps):
        dot_str += '{}[label="{{{}{}|{}}}"]\n'.format(
            id(step), r"-\> " if first else "", step.name,
            "\\n".join(descr for descr in step_descr[idx]))
        first = False

        if (step.next != None):
            dot_str += '{} -> {}\n'.format(id(step), id(step.next))

    dot_str += '\n}\n'
    return dot_str


if __name__ == '__main__':
    this_folder = dirname(__file__)

    if len(sys.argv) != 2:
        print("Usage: {} <model>\n".format(sys.argv[0]))

    else:
        model_name = sys.argv[1]
        meta = metamodel_from_file(join(this_folder, 'recipere.tx'))
        model = meta.model_from_file(model_name)
        with codecs.open("{}.dot".format(model_name), 'w', encoding='utf-8') as f:
            f.write(recipe_to_dot(model))
